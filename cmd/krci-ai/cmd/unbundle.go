/*
Copyright © 2025 KubeRocketAI Team

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"

	"github.com/KubeRocketCI/kuberocketai/internal/bundle"
	"github.com/KubeRocketCI/kuberocketai/internal/cli"
	"github.com/KubeRocketCI/kuberocketai/internal/discovery"
)

// unbundleCmd represents the unbundle command
var unbundleCmd = &cobra.Command{
	Use:   "unbundle <file>",
	Short: "Extract files from a bundle into the project structure",
	Long: `Extract files from a bundle markdown file into the .krci-ai/ directory structure.

This command parses a bundle file (generated by 'krci-ai bundle') and extracts all
contained files back into the appropriate directories:
- Agent definitions to .krci-ai/agents/
- Task files to .krci-ai/tasks/
- Templates to .krci-ai/templates/
- Data files to .krci-ai/data/

By default, existing files will be overwritten.

Examples:
  krci-ai unbundle ./.krci-ai/bundle/all.md                # Extract complete bundle
  krci-ai unbundle custom-agents.md                        # Extract custom bundle
  krci-ai unbundle ./.krci-ai/bundle/pm-architect.md       # Extract specific agents
  krci-ai unbundle shared-bundle.md --dry-run              # Preview extraction without writing files`,
	Args: cobra.ExactArgs(1),
	RunE: runUnbundle,
}

func init() {
	rootCmd.AddCommand(unbundleCmd)

	// Add flags
	unbundleCmd.Flags().Bool("dry-run", false, "Preview extraction without writing files")
}

// runUnbundle executes the unbundle command
func runUnbundle(cmd *cobra.Command, args []string) error {
	// Create output and error handlers
	output := cli.NewOutputHandler()
	errorHandler := cli.NewErrorHandler()

	bundleFile := args[0]

	// Check if bundle file exists
	if _, err := os.Stat(bundleFile); os.IsNotExist(err) {
		errorHandler.HandleError(err, fmt.Sprintf("Bundle file not found: %s", bundleFile))
		return err
	}

	// Parse bundle file
	output.PrintProgress(fmt.Sprintf("Parsing bundle file: %s", bundleFile))

	file, err := os.Open(bundleFile)
	if err != nil {
		errorHandler.HandleError(err, "Failed to open bundle file")
		return err
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			output.PrintWarning(fmt.Sprintf("Failed to close bundle file: %v", closeErr))
		}
	}()

	extractedFiles, err := bundle.ParseBundle(file)
	if err != nil {
		errorHandler.HandleError(err, "Failed to parse bundle")
		return err
	}

	output.PrintSuccess(fmt.Sprintf("Parsed %d files from bundle", len(extractedFiles)))

	// Get project root
	projectRoot, err := discovery.GetProjectRoot()
	if err != nil {
		errorHandler.HandleError(err, "Failed to get project root")
		return err
	}

	// Create extractor
	extractor := bundle.NewExtractor(projectRoot)

	// Get dry-run flag
	dryRun, err := cmd.Flags().GetBool("dry-run")
	if err != nil {
		return fmt.Errorf("failed to read dry-run flag: %w", err)
	}

	if dryRun {
		showExtractionPreview(output, extractor, extractedFiles)
		return nil
	}

	return extractFiles(output, errorHandler, extractor, extractedFiles)
}

// showExtractionPreview displays what would be extracted without writing files
func showExtractionPreview(output *cli.OutputHandler, extractor *bundle.Extractor, files []bundle.ExtractedFile) {
	output.PrintSuccess("Extraction Preview (Dry Run):")
	output.PrintInfo(fmt.Sprintf("  Files to extract: %d", len(files)))

	paths := extractor.DryRun(files)

	output.Newline()
	output.PrintInfo("Files to be extracted:")
	for _, path := range paths {
		// Check if file exists
		if _, err := os.Stat(path); err == nil {
			output.PrintWarning(fmt.Sprintf("  • %s (will be overwritten)", path))
		} else {
			output.PrintInfo(fmt.Sprintf("  • %s (new)", path))
		}
	}

	output.Newline()
	output.PrintInfo("Run without --dry-run to extract files")
}

// extractFiles extracts files to the filesystem
func extractFiles(output *cli.OutputHandler, errorHandler *cli.ErrorHandler, extractor *bundle.Extractor, files []bundle.ExtractedFile) error {
	output.PrintProgress("Extracting files to project structure...")

	stats, err := extractor.Extract(files)
	if err != nil {
		errorHandler.HandleError(err, "Failed to extract files")
		return err
	}

	// Success
	output.PrintSuccess("Files extracted successfully!")
	output.PrintInfo(fmt.Sprintf("  New files: %d", stats.FilesExtracted))
	output.PrintInfo(fmt.Sprintf("  Overwritten files: %d", stats.FilesOverwritten))
	output.PrintInfo(fmt.Sprintf("  Directories created: %d", stats.DirsCreated))

	output.Newline()
	output.PrintInfo("Next steps:")
	output.PrintInfo("• Run 'krci-ai validate' to verify extracted framework components")
	output.PrintInfo("• Review extracted agents with 'krci-ai list agents'")

	return nil
}
